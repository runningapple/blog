---
title: 乐观锁与悲观锁
date: 2017-12-04 22:57:58
comments: false
categories: R&D
tags: [R&D,技术,研发]
---
为什么有的人可以把生活过得那么精彩，而有的人却把人生过得那么枯燥？私以为这是心态问题，乐观与悲观，世界将是两个模样。  

---
在数据库里也有这么一对“锁”兄弟，它们一个乐观，一个悲观。乐观的那位名字叫乐观锁，消极的那位名字叫悲观锁。这对兄弟的主要作用是用来处理并发问题的。  

# 乐观锁机制（乐观并发控制）  
乐观锁是一种并发控制方法，它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。--wikipedia  

乐观锁实现方式：
    1. 版本号校验。在表中添加一个版本号字段，更新数据时检查版本号是否一致来确定是否可以更新数据。  
    2. 时间戳。使用时间戳也是同理，只是版本号验证改成了验证获取到的时间和更新前取到的时间戳进行校验。，如果一致则更新数据，否则不更新。  

```sql
/**以下模拟是根据版本号校验方式实现乐观锁。**/
--查询商品休息
select price, status, name, version from t_goods where id = #{id};

--修改商品状态
update t_goods set status=2, version=version+1 where id=#{id} and version=#{version};
```  

乐观并发控制相信事务之间的数据竞争的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题（ABA问题）。  

# 悲观锁机制（乐观并发控制） 
悲观并发控制是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作读某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。  

悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。

并发控制中典型的冲突有：
* 丢失更新：一个事务的更新覆盖了其它事务的更新结果，就是所谓的更新丢失。例如：用户A把值从6改为2，用户B把值从2改为6，则用户A丢失了他的更新。（ABA问题）  
* 脏读：当一个事务读取其它完成一半事务的记录时，就会发生脏读取。例如：用户A,B看到的值都是6，用户B把值改为2，用户A读到的值仍为6。  
http://blog.leanote.com/post/ggglllccc/%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81

http://www.cnblogs.com/0201zcr/p/4782283.html

http://www.programcat.com/index/info/id/32